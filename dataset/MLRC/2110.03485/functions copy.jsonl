{"paper_id": "2110.03485", "func_id": "0", "file": "cartoonx/cartoonX.py", "name": "step", "header_line": "42", "line_start": "43", "line_end": "91", "relevant_paper": "CartoonX, as described in Algorithm \\ref{alg: cartoon RDE}, computes the RDE mask in the wavelet domain of images. More precisely, for the data representation $x = f(h)$,\nwe choose $h$ as the concatenation of all the DWT coefficients along the channels, \\ie, $h_i\\in\\R^{c}$. The representation function $f$ is then the discrete inverse wavelet transform, \\ie, the summation of the DWT coefficients times the DWT basis vectors. We optimize the mask $s\\in[0,1]^k$ on the DWT coefficients $[h_1,\\hdots,h_k]^T$ to minimize RDE's $\\ell_1$-relaxation from Definition \\ref{def:ell_1 relaxation}. For the obfuscation strategy $\\mathcal{V}$, we use adaptive Gaussian noise with a partition by the DWT scale (see Section \\ref{subsubsec: obfuscation strategies}), \\ie, we compute the empirical mean and standard deviation per scale. %We measure distortion as the squared difference in the post-softmax score of the predicted label for $x$ (see Section \\ref{subsubsec: measures of distortion}).\nTo visualize the final DWT mask $s$ as a piece-wise smooth image in pixel space, we multiply the mask with the DWT coefficients of the greyscale image $\\hat x$ of $x$ before inverting the product back to pixel space with the inverse DWT. The pixel values of the inversion are finally clipped into $[0,1]$ as are obfuscations during the RDE optimization to avoid overflow (we assume here the pixel values in $x$ are normalized into $[0,1]$). The clipped inversion in pixel space is the final CartoonX explanation.\n\n\n\\RestyleAlgo{ruled} \n\\SetKwInput{kwHparams}{Hyperparameters}\n\\SetKwInput{kwInit}{Initialization}\n\n\\begin{algorithm}[hbt!]\n\n\\caption{CartoonX}\\label{alg: cartoon RDE}\n\\KwData{Image $x\\in[0,1]^n$ with $c$ channels and $k$ pixels, pre-trained classifier $\\Phi$.}\n \\kwInit{Initialize mask $s\\coloneqq[1,...,1]^T$ on\\\\ \\\\ DWT coefficients $h=[h_1,...,h_k]^T$ with $x=f(h)$, where $f$ is the inverse DWT. Choose sparsity level $\\lambda>0$, number of steps $N$,  number of noise samples $L$, and measure of distortion $d$.}\n  \\For{$i\\gets1$ \\KwTo $N$}{\n    Sample $L$ adaptive Gaussian noise samples $v^{(1)},...,v^{(L)}\\sim \\mathcal{N}(\\mu,\\sigma^2)$\\;\n    Compute obfuscations $y^{(1)},..., y^{(L)}$ with $y^{(i)}\\coloneqq f(h\\odot s + (1-s)\\odot v^{(i)})$\\;\n    Clip obfuscations into $[0,1]^{n}$\\;\n    Approximate expected distortion $\\hat D(x,s,\\Phi)\\coloneqq \\sum_{i=1}^Ld(\\Phi(x),\\Phi(y^{(i)}))^2/L$\\;\n    Compute loss for the mask, \\ie, $\\ell(s)\\coloneqq \\hat D(x,s,\\Phi) + \\lambda \\|s\\|_1$\\;\n    Update mask $s$ with gradient descent step using $\\nabla_s \\ell(s)$ and clip $s$ back to $[0,1]^{k}$\\;\n    }\n    Get DWT coefficients $\\hat h$ for greyscale image $\\hat x$ of $x$\\;\n    Set ${\\mathcal{E}}\\coloneqq f(\\hat h \\odot s)$ and finally clip ${\\mathcal{E}}$ into $[0,1]^{k}$\\;\n\\end{algorithm}", "description": "Performs a step in the optimization process to obfuscate DWT coefficients and evaluates the resulting image.\n\n:param std_yl: float - Standard deviation for noise perturbation of LL band (yl) coefficients.\n:param mean_yl: float - Mean for noise perturbation of LL band (yl) coefficients.\n:param std_yh: list - List of standard deviations for noise perturbation of each sub-band in the YH band coefficients.\n:param mean_yh: list - List of means for noise perturbation of each sub-band in the YH band coefficients.\n:param yl: torch.Tensor - LL band DWT coefficients.\n:param yh: list of torch.Tensor instances - List of YH band DWT coefficients for different sub-bands.\n:param s_yl: torch.Tensor - Mask over LL band coefficients (yl).\n:param s_yh: list of torch.Tensor instances - List of masks over YH band coefficients for different sub-bands.\n:param score: float or torch.Tensor - Initial label probability or distribution of probabilities for the original image.\n:param target: int, None, or list with two entries - Specifies the target label or method of distortion measurement (e.g., ell2 or kl-divergence), or [target_probabilities, weight] for weighted ell2.\n:param num_mask_entries: int - Number of entries in the mask(s).\n\n:modifies: None\n\n:effects: None directly; computes and prints results if used that way.\n\n:return: A tuple containing:\n    - distortion (float or torch.Tensor): Measure of the difference between the original and obfuscated image scores.\n    - sparsity (float): Average absolute value of the mask entries, representing the sparsity loss.\n    - is_same_classification (bool): Indicates whether the obfuscated image is classified into the same target class."}
{"paper_id": "2110.03485", "func_id": "1", "file": "cartoonx/cartoonX.py", "name": "get_distortion", "header_line": "93", "line_start": "94", "line_end": "119", "relevant_paper": "", "description": "Computes the distortion between the predicted scores for the obfuscated input and the original input using a specified measure.\nThis function evaluates different methods to calculate the distortion based on the self.distortion_measure attribute.\n\n:param new_preds: The predicted scores for the obfuscated input. It is expected to be a tensor.\n:param score: The original predicted scores before obfuscation. It should be a tensor with specific dimensions depending on the distortion measure.\n:param target: The target class index, used when self.distortion_measure is set to \"label\" or \"maximize-target\".\n:modifies: This function does not modify any global or class variables directly, but it uses the self.distortion_measure attribute to decide how to compute distortion.\n:effects: If the distortion measure is not implemented, it raises a NotImplementedError.\n:return: A tensor representing the calculated distortion value based on the specified measure."}
{"paper_id": "2110.03485", "func_id": "2", "file": "cartoonx/cartoonX.py", "name": "get_scaled_mask", "header_line": "121", "line_start": "122", "line_end": "128", "relevant_paper": "", "description": "Transforms and scales a given mask tensor to a specified size, applies a threshold, and replaces zero values with a small constant epsilon.\n\n:param size: An integer or a tuple specifying the desired dimensions to resize the mask to. If an integer is provided, the mask is resized to a square with side length equal to the integer.\n:param mask: A tensor representing the mask that needs to be transformed and resized.\n:modifies: None\n:effects: Converts the mask to a tensor on the specified device, resizes it, applies a threshold operation, and replaces zero values.\n:return: A transformed tensor of type float32 where zero values have been replaced by the constant epsilon."}
{"paper_id": "2110.03485", "func_id": "3", "file": "cartoonx/cartoonX.py", "name": "initialize_dwt_mask", "header_line": "130", "line_start": "131", "line_end": "218", "relevant_paper": "", "description": "Generates masks for wavelet transform coefficients based on the specified initialization method. The mask can be initialized as ones, zeros, random values, or based on the foreground segmentation of an image.\n\n:param yl: Tensor for low-frequency wavelet coefficients. Its `requires_grad` attribute will be set to False.\n:param yh: List of Tensors for high-frequency wavelet coefficients. Each tensor in the list will have its `requires_grad` attribute set to False.\n:param path: A string representing the file path to the image which is used when `self.init_mask` is set to \"foreground\".\n:param epsilon: A float value used to scale the initial mask values when `self.init_mask` is \"ones\" or during the scaling process for the wavelet coefficients.\n\n:modifies yl.requires_grad_: Sets the `requires_grad` attribute of the `yl` tensor to False.\n:modifies yh.requires_grad_: Sets the `requires_grad` attribute of each tensor in the `yh` list to False.\n:effects: Raises a `NotImplementedError` if `self.init_mask` is not \"ones\", \"zeros\", \"rand\", or \"foreground\".\n\n:return: A tuple containing:\n    - `s_yl`: A tensor representing the mask for low-frequency coefficients.\n    - `s_yh`: A list of tensors representing the masks for high-frequency coefficients.\n    - `num_mask_entries`: An integer representing the total number of elements in the masks."}
{"paper_id": "2110.03485", "func_id": "4", "file": "cartoonx/cartoonX.py", "name": "__call__", "header_line": "220", "line_start": "221", "line_end": "376", "relevant_paper": "", "description": "Performs differential wavelet transform (DWT) based image obfuscation strategy, followed by optimization to minimize a specified distortion measure.\n\n:param x: A tensor representing the input image with shape (1, C, H, W) where C is the number of color channels, H and W are the height and width of the image respectively.\n:param preoptimize: A boolean indicating whether to run preoptimization steps.\n:param path: File path or directory used during the initialization of masks.\n:param target: A target label used in distortion measurement, with specifics depending on the distortion measurement method.\n:param save_mask_after: A list of iteration steps at which the intermediate mask is saved.\n\n:modifies self.obfuscation_strategy: Uses the obfuscation strategy specified by self.obfuscation_strategy.\n:modifies self.distortion_measure: Uses the distortion measure specified by self.distortion_measure.\n:modifies self.C: Set during the weighted-l2 distortion measurement based on the target parameter.\n:modifies s_yl, s_yh: Tensors modified during optimization to minimize distortion according to the obfuscation strategy and distortion measure.\n:modifies logs: Dictionary storing logs of various loss components during the optimization.\n\n:effects: Prints the progress of the iteration process and intermediate results during preoptimization.\n:effects: Raises NotImplementedError if an unsupported obfuscation strategy or distortion measure is provided.\n\n:return: A tuple containing:\n    - cartoonX: The obfuscated image in pixel space as a tensor, normalized between 0 and 1.\n    - mask: The DWT space obfuscation mask as a list containing low-pass and high-pass components.\n    - logs: A dictionary recording various loss components over the optimization process.\n    - intermediate_masks: A list of masks saved at specified iteration steps."}
